(* This file provides glue code for building the pretty printer using the parser and lexer specified 
   in prettyPrinter.lex and prettyPrinter.grm. *)

(* Creating the lexer and parser for our grammar using functors generated by ML-Lex and ML-Yacc
    from the descriptions provided in the corresponding .lex and .grm files *)
structure PrettyPrinterLrVals =
    PrettyPrinterLrValsFun ( structure Token = LrParser.Token )
structure PrettyPrinterLex = 
    PrettyPrinterLexFun ( structure Tokens = PrettyPrinterLrVals.Tokens )
structure PrettyPrinterParser =
    JoinWithArg ( structure ParserData = PrettyPrinterLrVals.ParserData
                  structure Lex = PrettyPrinterLex
                  structure LrParser = LrParser )

structure PrettyPrinter = struct
    
    exception PrettyPrinterError;

    val result = ref "";
    fun printSpaces cnt = if cnt = 0 then ()
                                     else (result := !result ^ "    "; printSpaces (cnt - 1));
    
    fun printExp (AST.Nil) pos =                    (printSpaces pos;
                                                     result := !result ^ "nil ")
    |   printExp (AST.Integer x) pos =              (printSpaces pos;
                                                     result := !result ^ (Int.toString x) ^ " ")
    |   printExp (AST.String x) pos =               (printSpaces pos;
                                                     result := !result ^ x ^ " ")
    |   printExp (AST.Lval x) pos =                 (printSpaces pos;
                                                     printLvalue x pos)
    |   printExp (AST.Negation x) pos =             (printSpaces pos;
                                                     result := !result ^ "-";
                                                     printExp x 0)
    |   printExp (AST.Exps x) pos =                 (printSpaces pos;
                                                     result := !result ^ "(\n";
                                                     printExps x (pos + 1);
                                                     printSpaces pos; 
                                                     result := !result ^ ") ")
    |   printExp (AST.FunCall (x, y)) pos =         (printSpaces pos;
                                                     result := !result ^ x ^ " ( ";
                                                     printExpList y;
                                                     result := !result ^ ") ")
    |   printExp (AST.App (x, y, z)) pos =          (printExp x pos;
                                                     printOperator y;
                                                     printExp z 0)
    |   printExp (AST.Array (x, y, z)) pos =        (printSpaces pos;
                                                     result := !result ^ "array " ^ x ^ " [ ";
                                                     printExp y 0;
                                                     result := !result ^ " ] of ";
                                                     printExp z 0)
    |   printExp (AST.Record (x, y)) pos =          (printSpaces pos;
                                                     result := !result ^ x ^ " { ";
                                                     printStringExpList y;
                                                     result := !result ^ " } ")
    |   printExp (AST.Assignment (x, y)) pos =      (printSpaces pos;
                                                     printLvalue x 0;
                                                     result := !result ^ ":= ";
                                                     case y of 
                                                        AST.Nil          => printExp y 0 |
                                                        AST.Integer _    => printExp y 0 |
                                                        AST.String _     => printExp y 0 |
                                                        AST.Lval _       => printExp y 0 |
                                                        AST.Negation _   => printExp y 0 |
                                                        AST.FunCall _    => printExp y 0 |
                                                        AST.Array _      => printExp y 0 |
                                                        AST.App _        => printExp y 0 |
                                                        AST.Record _     => printExp y 0 |
                                                        _                => (result := !result ^ "\n";
                                                                             printExp y (pos + 1);
                                                                             result := !result ^ "\n"))
    |   printExp (AST.IfThenElse (x, y, z)) pos =   (printSpaces pos;
                                                     result := !result ^ "if\n";
                                                     printExp x (pos + 1);
                                                     result := !result ^ "\n";
                                                     printSpaces pos;
                                                     result := !result ^ "then\n";
                                                     printExp y (pos + 1);
                                                     result := !result ^ "\n";
                                                     printSpaces pos;
                                                     result := !result ^ "else\n";
                                                     printExp z (pos + 1))
    |   printExp (AST.IfThen (x, y)) pos =          (printSpaces pos;
                                                     result := !result ^ "if\n";
                                                     printExp x (pos + 1);
                                                     result := !result ^ "\n";
                                                     printSpaces pos;
                                                     result := !result ^ "then\n";
                                                     printExp y (pos + 1))
    |   printExp (AST.While (x, y)) pos =           (printSpaces pos;
                                                     result := !result ^ "while\n";
                                                     printExp x (pos + 1);
                                                     result := !result ^ "\n";
                                                     printSpaces pos;
                                                     result := !result ^ "do\n";
                                                     printExp y (pos + 1))
    |   printExp (AST.For (x, y, z, w)) pos =       (printSpaces pos;
                                                     result := !result ^ "for " ^ x ^ " :=\n";
                                                     printExp y (pos + 1);
                                                     result := !result ^ "\n";
                                                     printSpaces pos;
                                                     result := !result ^ "to\n";
                                                     printExp z (pos + 1);
                                                     result := !result ^ "\n";
                                                     printSpaces pos;
                                                     result := !result ^ "do\n";
                                                     printExp w (pos + 1))
    |   printExp (AST.Let (x, y)) pos =             (printSpaces pos;
                                                     result := !result ^ "let\n";
                                                     printDecList x (pos + 1);
                                                     printSpaces pos;
                                                     result := !result ^ "in\n";
                                                     printExps y (pos + 1);
                                                     printSpaces pos;
                                                     result := !result ^ "end ")
    |   printExp (AST.Comment x) pos =              (result := !result ^ x)

    and printExps (x::y::xs) pos =                  (printExp x pos;
                                                     result := !result ^ "\b;\n";
                                                     printExps (y::xs) pos)
    |   printExps (x::xs) pos =                     (printExp x pos;
                                                     result := !result ^ "\b\n")
    |   printExps _ _ =                             ()

    and printExpList (x::y::xs) =                   (printExp x 0;
                                                     result := !result ^ ", ";
                                                     printExpList (y::xs))
    |   printExpList (x::xs) =                      (printExp x 0;
                                                     result := !result ^ " ")
    |   printExpList _ =                            ()

    and printStringExpList ((x, y)::z::xs)=         (result := !result ^ x ^ " = ";
                                                     printExp y 0;
                                                     result := !result ^ ", ";
                                                     printStringExpList (z::xs))
    |   printStringExpList ((x, y)::xs) =           (result := !result ^ x ^ " = ";
                                                     printExp y 0)
    |   printStringExpList _ =                      ()

    and printLvalue (AST.Id x) pos =                (result := !result ^ x ^ " ")
    |   printLvalue (AST.Subscript (x, y)) pos =    (printLvalue x;
                                                     result := !result ^ "[ ";
                                                     printExp y 0;
                                                     result := !result ^ "] ")
    |   printLvalue (AST.Field (x, y)) pos =        (printLvalue x;
                                                     result := !result ^ "." ^ y ^ " ")

    and printDecList (x::xs) pos =                  (printDec x pos;
                                                     printDecList xs pos)
    |   printDecList _ _ =                          ()

    and printDec (AST.TyDec x) pos =                (printTyDec x pos)
    |   printDec (AST.VDec y) pos =                 (printVDec y pos)
    |   printDec (AST.FDec z) pos =                 (printFDec z pos)

    and printTyDec (AST.TypeAssignment(x, y)) pos = (printSpaces pos;
                                                     result := !result ^ "type " ^ x ^ " = " ^ y ^ "\n")
    |   printTyDec (AST.ArrayType (x, y)) pos =     (printSpaces pos;
                                                     result := !result ^ "type " ^ x ^ " = " ^ "array of " ^ y ^ "\n")
    |   printTyDec (AST.RecordType (x, y)) pos =    (printSpaces pos;
                                                     result := !result ^ "type " ^ x ^ " = { ";
                                                     printRecordTypeList y;
                                                     result := !result ^ " }\n")

    and printRecordTypeList ((x, y)::z::xs) =       (result := !result ^ x ^ " = " ^ y ^ ", ";
                                                     printRecordTypeList (z::xs))
    |   printRecordTypeList ((x, y)::xs) =          (result := !result ^ x ^ " = " ^ y;
                                                     printRecordTypeList xs)
    |   printRecordTypeList _ =                     ()

    and printVDec (AST.Var (x, y)) pos =            (printSpaces pos;
                                                     result := !result ^ "var " ^ x ^ " := ";
                                                     case y of 
                                                        AST.Nil          => printExp y 0 |
                                                        AST.Integer _    => printExp y 0 |
                                                        AST.String _     => printExp y 0 |
                                                        AST.Lval _       => printExp y 0 |
                                                        AST.Negation _   => printExp y 0 |
                                                        AST.FunCall _    => printExp y 0 |
                                                        AST.Array _      => printExp y 0 |
                                                        AST.App _        => printExp y 0 |
                                                        AST.Record _     => printExp y 0 |
                                                        _                => (result := !result ^ "\n";
                                                                             printExp y (pos + 1);
                                                                             result := !result ^ "\n");
                                                     result := !result ^ "\n")
    |   printVDec (AST.VarType (x, y, z)) pos =     (printSpaces pos;
                                                     result := !result ^ "var " ^ x ^ " : " ^ y ^ " := ";
                                                     case z of 
                                                        AST.Nil          => printExp z 0 |
                                                        AST.Integer _    => printExp z 0 |
                                                        AST.String _     => printExp z 0 |
                                                        AST.Lval _       => printExp z 0 |
                                                        AST.Negation _   => printExp z 0 |
                                                        AST.FunCall _    => printExp z 0 |
                                                        AST.Array _      => printExp z 0 |
                                                        AST.App _        => printExp z 0 |
                                                        AST.Record _     => printExp z 0 |
                                                        _                => (result := !result ^ "\n";
                                                                             printExp z (pos + 1);
                                                                             result := !result ^ "\n");
                                                     result := !result ^ "\n")

    and printFDec (AST.Fun (x, y, z)) pos =         (printSpaces pos;
                                                     result := !result ^ "function " ^ x ^ " ( ";
                                                     printRecordTypeList y;
                                                     result := !result ^ " ) = ";
                                                     case z of 
                                                        AST.Nil          => printExp z 0 |
                                                        AST.Integer _    => printExp z 0 |
                                                        AST.String _     => printExp z 0 |
                                                        AST.Lval _       => printExp z 0 |
                                                        AST.Negation _   => printExp z 0 |
                                                        AST.FunCall _    => printExp z 0 |
                                                        AST.Array _      => printExp z 0 |
                                                        AST.App _        => printExp z 0 |
                                                        AST.Record _     => printExp z 0 |
                                                        _                => (result := !result ^ "\n";
                                                                             printExp z (pos + 1));
                                                     result := !result ^ "\n")
    |   printFDec (AST.FunType (x, y, z, w)) pos =  (printSpaces pos;
                                                     result := !result ^ "function " ^ x ^ " ( ";
                                                     printRecordTypeList y;
                                                     result := !result ^ " ) : " ^ z ^ " = ";
                                                     case w of 
                                                        AST.Nil          => printExp w 0 |
                                                        AST.Integer _    => printExp w 0 |
                                                        AST.String _     => printExp w 0 |
                                                        AST.Lval _       => printExp w 0 |
                                                        AST.Negation _   => printExp w 0 |
                                                        AST.FunCall _    => printExp w 0 |
                                                        AST.Array _      => printExp w 0 |
                                                        AST.App _        => printExp w 0 |
                                                        AST.Record _     => printExp w 0 |
                                                        _                => (result := !result ^ "\n";
                                                                            printExp w (pos + 1));
                                                     result := !result ^ "\n")

    and   printOperator AST.Plus =                  (result := !result ^ "+ ")
    |     printOperator AST.Minus =                 (result := !result ^ "- ")         
    |     printOperator AST.Multiply =              (result := !result ^ "* ")         
    |     printOperator AST.Divide =                (result := !result ^ "/ ")         
    |     printOperator AST.NotEqual =              (result := !result ^ "<> ")         
    |     printOperator AST.Equals =                (result := !result ^ "= ")         
    |     printOperator AST.Less =                  (result := !result ^ "< ")         
    |     printOperator AST.Greater =               (result := !result ^ "> ")         
    |     printOperator AST.GreaterEqual =          (result := !result ^ ">= ")         
    |     printOperator AST.LessEqual =             (result := !result ^ "<= ")
    |     printOperator AST.And =                   (result := !result ^ "& ")         
    |     printOperator AST.Or =                    (result := !result ^ "| ");


    fun printTree (x::xs) = (printExp x 0; 
                             result := !result ^ "\n"; 
                             printTree xs)
    |   printTree _ = TextIO.print ((!result) ^ "\n======COMPLETED======\n");
    

    fun prettyPrint fileName =
        let val inStream = TextIO.openIn fileName;
            fun grab n = if TextIO.endOfStream inStream then "" else TextIO.inputN (inStream, n);
            fun printError (msg, line, col) = print (fileName ^ "[" ^ Int.toString line ^ ":" 
                                                  ^ Int.toString col ^ "] " ^ msg ^ "\n");
            val (tree, rem) = PrettyPrinterParser.parse (15, (PrettyPrinterParser.makeLexer grab fileName), printError, fileName)
            handle PrettyPrinterParser.ParseError => raise PrettyPrinterError;
            (* Close the source program file *)
            val _ = TextIO.closeIn inStream;
        in (result := ""; printTree tree) end

end;